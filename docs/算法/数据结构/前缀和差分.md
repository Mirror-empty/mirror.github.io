# 前缀和差分

![pSlLsRP.png](https://s1.ax1x.com/2023/01/16/pSlLsRP.png)

去求区间和，连续数组（子数组），区间查询，仅区间更新操作频繁时，应使用差分数组。

前缀和、差分是算法，更是思想，尤其作为一种常用的预处理技巧，在很多题目中都有应用，需要熟练掌握其特性。

在应用时，常先把原数组转化为前缀和数组或差分数组，再在此基础上应用稍高级的数据结构或算法。

### 前缀和

**一维的**

前缀和是指谋序列的前n项和，就是数学中数列的前n项和，差分就是前缀和的逆运算。``Sn - Sn-1 = an`` 数学的等差公式

也可以认为是动态规划，转移方程就是数学的公式。

```java
        for (int i = 1; i < nums.length ; i++) {
            nums[i] = nums[i-1] + nums[i];
        }
        return nums;
```


**二维**



```java
s[i][j]=a[1][1]+a[1][2]+……+a[1][j]+
        a[2][1]+a[2][2]+……+a[2][j]+
        .
        .
        .
        a[i][1]+a[i][2]+……+a[i][j];
```

基于二维数组的前缀和主要应用场景是可以在O(1)情况下求出任何子矩阵的和

例如：我们打算求红色子矩阵的和，我们可以使用紫色的子矩阵和-绿色的子矩阵和-蓝色的子矩阵和+黑色子矩阵和（因为黑色子矩阵在减绿色和蓝色时减了两次，所以要加上一个黑色）。我们使用s1的值表示黑色子矩阵的和，s2的值表示绿色子矩阵的和，s3表示蓝色子矩阵的和，s4表示紫色子矩阵的和，那么所求子矩阵和=s4(右下角)-s2(右上角)-s3(左下角)+s1(左上角)

看个具体例子，设s1的位置是(m,n)，s4的位置是(x,y)，则s2的位置是(x-m,y)，s3的位置是(x,y-n)

求的是每个矩阵左上角的起点

``所求子矩阵和=s[x][y]-s[x][y-n]-s[x-m][y]+s[m,n];``

### 差分

a 数组是 b 数组的前缀和。

对于差分来说，他的应用范围比较单一，主要用于可以让一个序列中某个区间内的所有值均加上或减去一个常数。

所以差分往往应用于线性的场合，即一维数组的环境。

差分是指，序列中每个元素与其前一个元素的差。

**一维**

//设原数组为a
int a[100];
//设差分数组为b
int b[100];

我们一般认为原序列就是差分序列的前缀和，所以把差分看做前缀和的逆运算，来看下面的例子：

```java

//a[]为原数组,b[]为差分数组
b[1]+b[2]+……+b[i]
=a[1]+a[2]-a[1]+a[3]-a[2]+……+a[i]-a[i-1]
=a[i]
即a[i]=b[1]+b[2]+……+b[i]，所以原序列为差分序列的前缀和序列
```

一起来看个实际的例子：

```java
a[5]=b[1]+b[2]+b[3]+b[4]+b[5]
    =a[1]+a[2]-a[1]+a[3]-a[2]+a[4]-a[3]+a[5]-a[4]
    =a[5]
    
```

```java
a[0 ]= 0;

b[1] = a[1] - a[0];

b[2] = a[2] - a[1];

b[3] = a [3] - a[2];

........

b[n] = a[n] - a[n - 1];
```

a数组是b数组的前缀和数组，比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。

首先让差分b数组中的 b[l] + c ,通过前缀和运算，a数组变成 a[l] + c ,a[l + 1] + c,,,,,, a[n] + c;

然后我们打个补丁，b[r + 1] - c, 通过前缀和运算，a数组变成 a[r + 1] - c,a[r + 2] - c,,,,,,,a[n] - c;

为啥还要打个补丁？

我们画个图理解一下这个公式的由来:


b[l] + c，效果使得a数组中 a[l] 及以后的数都加上了c(红色部分)，但我们只要求l到r 区间加上 c, 因此还需要执行 b[r + 1] - c,让a数组中 a[r + 1]及往后的区间再减去c(绿色部分)，这样对于a[r] 以后区间的数相当于没有发生改变。

因此我们得出一维差分结论：给a数组中的[ l, r] 区间中的每一个数都加上c,只需对差分数组b做 b[l] + = c, b[r+1] - = c 。时间复杂度为O(1), 大大提高了效率。




看题

```java
    public int[] corpFlightBookings(int[][] bookings, int n) {
        int[] nums = new int[n];
        int[] b = new int [n];
        for (int i = 0; i < bookings.length; i++) {
            int start=bookings[i][0];
            int end = bookings[i][1];
            int value=bookings[i][2];
            // 去求差分数组，差分数组通过题意和原数组去求。
            b=insertone(start-1, end<n?end:-1,value,b);
        }
        nums[0]=b[0];
        for (int i = 1; i < n; i++) {
            nums[i]=nums[i-1]+b[i];
        }
        return nums;
    }

    private int [] insertone(int i, int j, int c, int[] b) {
        // 暴力破解
        // for (int k = i; k <j; k++) {
        //     b[k]+=c;
        // }
        // 这里+c相当于 a[i] 后面都会加c 减也是一样
        b[i]+=c;
        if (j!=-1){
        b[j]-=c;
        }
        return b;
    }
```


**二维**

如何构造b数组呢？

其实关于差分数组，我们并不用考虑其构造方法，因为我们使用差分操作在对原数组进行修改的过程中，实际上就可以构造出差分数组。

同一维差分，我们构造二维差分数组目的是为了 让原二维数组a中所选中子矩阵中的每一个元素加上c的操作，可以由O(n*n)的时间复杂度优化成O(1)

已知原数组a中被选中的子矩阵为 以(x1,y1)为左上角，以(x2,y2)为右下角所围成的矩形区域;

始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i][j]的修改，会影响到a数组中从a[i][j]及往后的每一个数。

假定我们已经构造好了b数组，类比一维差分，我们执行以下操作
来使被选中的子矩阵中的每个元素的值加上c

b[x1][y1] + = c ;

b[x1,][y2+1] - = c;

b[x2+1][y1] - = c;

b[x2+1][y2+1] + = c;

每次对b数组执行以上操作，等价于：

```java
for(int i = x1;i <= x2;i++)
  for(int j = y1;j <= y2;j++)
    a[i][j] += c;
```

```java
void insert(int x1,int y1,int x2,int y2,int c)
{     //对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
```

