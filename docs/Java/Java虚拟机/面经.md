# 面经

### JDK、JRE、JVM

- JDK，JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了jre。其中开发工具包括（javac.exe）打包工具（jar.exe）。
- JRE（java 运行环境） 是JDK 的子集，jre 提供了库，java虚拟机和其他组件
- jvm，jvm 虚拟机，具备着计算机的基本运算方式，它主要负责把java程序生成的字节码文件，解释成具体系统平台上的机器指令，使其在各个平台运行。

### 类加载

JVM类加载过程：

- 加载：通过一个类的权限定名类获取定义此类的二进制字节流，将二进制字节流的静态存储结构转换为方法区中运行时的存储结构，在内存中生成Class对象，将它放在方法区使这个类是各种数据的访问入口。
- 链接：三种阶段
  - 验证：文件格式验证，元数据、字节码、符号引用验证。确保被加载类的正确性，验证字节流是否符合 class 文件规范，
  - 准备：正式为类变量分配内存并设置初始值
  - 解析：把间接引用转换为直接引用。 解析包括解析出常量池数据和属性表信息
- 初始化：最后一步，标记常量值的字段赋值。通过锁的方式确保clint方法只被执行一次。 初始化类变量 静态方法块
- 使用：程序代码执行使用阶段
- 卸载：程序代码退出、异常、结束等。


### 内存模型

- JDK 1.6：有永久代，静态变量存放在永久代上。
- JDK 1.7：有永久代，字符串常量池、静态变量、存放在堆上。逐渐减少永久代的使用。
- JDK 1.8：无永久代，运行时 常量池、类常量池，保存在元数据区，也就是元空间，但字符串常量池仍然存放在堆上。

1. 程序计数器

记录当前线程的字节码指令的地址。

2. Java虚拟机栈

每个方法在执行的时候，会创建一个栈帧，栈帧中包含了 操作数栈，局部变量表，动态链接，方法出口，线程，常量池引用等信息。

每个方法的调用直至执行完，对应了一个栈帧在java虚拟栈中的出栈和入栈的过程。

3. 本地方法栈

本地方法调用才会触发的，就是native关键字方法

和java虚拟栈一样会抛出 StackOverflowError 和 OutOfMemoryError 异常。

JDK1.8 HotSpot虚拟机直接就把本地方法栈和虚拟机栈合二为一。

4. 堆和元空间

- JDK 1.8 JVM 的内存结构主要由三大块组成：堆内存、元空间和栈，Java 堆是内存空间占据最大的一块区域。
- Java 堆，由年轻代和年老代组成，分别占据1/3和2/3。
- 而年轻代又分为三部分，Eden、From Survivor、To Survivor，占据比例为8:1:1，可调。
- 另外这里我们特意画出了元空间，也就是直接内存区域。在 JDK 1.8 之后就不在堆上分配方法区了。
- 元空间从虚拟机Java堆中转移到本地内存，默认情况下，元空间的大小仅受本地内存的限制，说白了也就是以后不会因为永久代空间不够而抛出OOM异常出现了

5. 常量池

- 字符串常量池存放在堆空间，用于存储字符串对象或是字符串对象的引用。


### JVM 故障处理工具

VisualVm 使用