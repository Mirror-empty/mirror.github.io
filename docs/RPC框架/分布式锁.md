# 分布式锁

### 什么是分布式锁

>要介绍分布式锁，首先要提到与分布式锁相对应的第线程锁、进程锁。

- 线程锁：主要用来给方法、代码块加锁。当某个方法或代码使用锁，在同一时刻仅有一个线程执行该方法或该代码段。线程锁只在同一JVM中有效果，因为线程锁的实现在根本上是依靠线程之间共享内存实现的，比如synchronized是共享对象头，显示锁Lock是共享某个变量（state）。
- 进程锁：为了控制同一操作系统中多个进程访问某个共享资源，因为进程具有独立性，各个进程无法访问其他进程的资源，因此无法通过synchronized等线程锁实现进程锁。
- 分布式锁：当多个进程不在同一个系统中（比如分布式系统中控制共享资源访问），用分布式锁控制多个进程对资源的访问。


分布式锁的设计原则

>分布式锁的最小设计原则：安全性和有效性

Redis的官网上对使用分布式锁提出至少需要满足如下三个要求：
1. 互斥（属于安全性）：在任何给定时刻，只有一个客户端可以持有锁。‘
2. 无死锁（属于有效性）：即使锁定资源的客户端崩溃或被分区，也总是可以获得锁；通常通过超时机制实现。
3. 容错性（属于有效性）：只要大多数Redis节点都启动，客户端都可以获取和释放锁。

初次之外，分布式锁的设计还可以/需要考虑：

1. 加锁解锁的同源性：A加的锁，不能被B解锁
2. 获取锁是非阻塞的：如果获取不到锁，不能无限期等待；
3. 高性能：加锁解锁是高性能的


在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。

阻塞锁通常使用互斥量来实现：

- 互斥量为0表示有其它进程在使用锁，此时处于锁定状态；
- 互斥量为1表示未锁定状态。

1和0可以用一个整型值表示，也可以用某个数据是否存在表示。

### 数据库的唯一索引

获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入异常，那么就可以用这个记录是否存在来判断是否处于锁定状态。

存在以下几个问题：

- 锁没有失效时间，解锁失败的话其它进程无法再获得该锁；
- 只能是非阻塞锁，插入失败直接就报错了，无法重试；
- 不可重入，已经获得锁的进程也必须重新获取锁。

对一个字段添加唯一索引的约束，如果每次插入相同的值，当值存在了，插入失败，表明已经持有锁了。

### Redis 的 SETNX指令

使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。

SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。

EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。

### Redis 的RedLock 算法

使用了多个Redis实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。

- 尝试从 N 个互相独立 Redis 实例获取锁；
- 计算获取锁消耗的时间，只有时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，才认为获取锁成功；
- 如果获取锁失败，就到每个实例上释放锁。


假设有两个服务A、B都希望获得锁，有一个包含了5个redis master的Redis Cluster，执行过程大致如下:
1. 客户端获取当前时间戳，单位: 
2. 毫秒服务A轮寻每个master节点，尝试创建锁。(这里锁的过期时间比较短，一般就几十毫秒) RedLock算法会尝试在大多数节点上分别创建锁，假如节点总数为n，那么大多数节点指的是n/2+1。
3. 客户端计算成功建立完锁的时间，如果建锁时间小于超时时间，就可以判定锁创建成功。如果锁创建失败，则依次(遍历master节点)删除锁。
4. 只要有其它服务创建过分布式锁，那么当前服务就必须轮寻尝试获取锁。

# 基于Redis的客户端

### 分布式锁的实现方案

>就体系的角度而言，谈谈常见的分布式锁的实现方案。

- 基于数据库实现分布式锁
  - 基于数据库表（锁表，很少使用）
  - 乐观锁（基于版本号）
  - 乐观锁（基于排它锁）

悲观锁，显示锁 select for update

- 基于redis实现分布式锁
  - 单个Redis实例：setnx（key，当前时间+过期时间）+ Lua
  - Redis集群模式：Redlock
- 基于zookeeper实现分布式锁
  - 临时有序节点来实现分布式锁Curator
- 基于Consul实现分布式锁


### 基于Redis的客户端

以基于Redisson实现分布式锁为例（支持了 单实例、Redis哨兵、redis cluster、redis master-slave等各种部署架构）：

**特色？**

redisson所有指令都通过lua脚本执行，保证了操作的原子性redisson设置了watchdog看门狗，“看门狗”的逻辑保证了没有死锁发生redisson支持Redlock的实现方式。

**过程？**

线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。线程去获取锁，获取失败: 订阅了解锁消息，然后再尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。

**互斥？**

如果这个时候客户端B来尝试加锁，执行了同样的一段lua脚本。第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在。接着第二个if判断，判断myLock锁key的hash数据结构中，是否包含客户端B的ID，但明显没有，那么客户端B会获取到pttl myLock返回的一个数字，代表myLock这个锁key的剩余生存时间。此时客户端B会进入一个while循环，不听的尝试加锁。

**watch dog自动延时机制？**

​客户端A加锁的锁key默认生存时间只有30秒，如果超过了30秒，客户端A还想一直持有这把锁，怎么办？其实只要客户端A一旦加锁成功，就会启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，如果客户端A还持有锁key，那么就会不断的延长锁key的生存时间。

**可重入？**

每次lock会调用incrby，每次unlock会减一。# 进一步理解借助Redis实现分布式锁时，有一个共同的缺陷: 当获取锁被拒绝后，需要不断的循环，重新发送获取锁(创建key)的请求，直到请求成功。这就造成空转，浪费宝贵的CPU资源。


### redis实现分布式锁

1. 其实的一般都是用基于Redlock算法实现的Redission来做的分布式锁
2. setnx + lua方式 来保证锁的健壮性。


**Redisson实现**

1. 加锁机制
2. 解锁机制
3. 生存时间延长机制
4. 可重入加锁机制
5. 释放加锁机制


通过hash算法选择集群中的一个节点，lua脚本执行逻辑代码，第一个客户端通过命令持有锁，会返回持锁的生存周期，然后生存时间到了，通过 watch dog看门狗去检查和延长持有锁的时间，导致第二个客户端不断自旋尝试获取锁

- [Springboot-实现Redisson](https://cloud.tencent.com/developer/article/1976433)
- [Redisson底层原理](https://juejin.cn/post/6850418111700680712)
- 