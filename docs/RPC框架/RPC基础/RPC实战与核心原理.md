# RPC实战与核心原理

### RPC基础概念

RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是；客户端不知道调用细节的情况下，调用存在与远程计算机上的某个对象，就想调用本地应用程序中的对象一样。

比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要连接底层网络技术的协议。

作用概括如下：
1. 屏蔽远程调用跟本地调用的区别，让我们感觉远程调用和本地调用一样便捷；
2. 隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。

RPC就是一种远程调用的协议，通过一系列方法使我们远程调用和本地调用没有区别。

从描述中挖掘出几个要点：

- RPC是协议：既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。
- 网络协议和网络IO模型对其透明：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP/UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。
- 信息格式对其透明：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。
- 应该有跨语言能力：为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。

### RPC原理

**RPC调用流程**

通信流程

![pSiDRTs.png](https://s1.ax1x.com/2023/01/03/pSiDRTs.png)

1. 服务消费方（Client）调用以本地方式调用服务；
2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；
3. client stub找到服务地址，并将消息发送到服务端；
4. server stub收到消息后进行解码；
5. server stub根据解码结果调用本地的服务；
6. 本地服务执行并将结果返回给server sub；
7. server stub将返回结果打包成消息并发送至消费方；
8. client stub接收到消息，并进行解码；
9. 服务消费方得到最终结果。

RPC的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。

![pSiri0H.png](https://s1.ax1x.com/2023/01/03/pSiri0H.png)


当Client发起一个远程调用时，它实际上是调用本地的Stub。本地Stub负责将调用的接口、方法和参数，通过约定的协议规范进行编码，并通过本地的RPCRuntime进行传输，然后将数据包发送到网络上传输出去。当Server端的RPCRuntime收到请求后，交给Server-Stub进行解码，然后调用服务端的方法，服务端执行方法，返回结果，Server-Stub将返回结果编码后，发送给Client，Client端的RPCRuntime收到结果，发给Client-Stub解码得到结果，返回给客户端。

这里面分了3个层次:

- 对于客户端和服务端，都像是本地调用一样，专注于业务逻辑的处理就可以了。
- 对于Stub层，处理双方约定好的语法、语义、封装、解封装。
- 对于RPCRuntime，主要处理高性能的传输，以及网络的错误和异常。


**数据序列化**

序列化就是将数据结构或对象转换成二进制的过程，也就是编码的过程，序列化后数据才方便进行网络传输；反序列化就是在序列化过程中所生成的二进制转换成数据结构或者对象的过程，将二进制转换为对象后业务才好进行后续的逻辑处理。

常见的序列化协议如下：

- protobuf(IDL)
- json
- xml
- Hessian2（Java系）

常见的RPC框架如gRPC、Thrift、Dubbo、RPCX 、Motan等会支持上述协议中的大部分，尤其是PB和json。目前从性能上和使用广泛度上来看，现在一般推荐使用PB，当然很多自研的框架里面他们也会自己实现他们自己的序列化协议。


**网络传输（网络通信）**

在数据被序列化为二进制后就可以行网络传输了，网络传输就是我们的数据怎么传输到对方服务器上，目前来说，常见的通信传输方式包括：TCP、UDP、HTTP（HTTP2.0）、QUIC协议、TCP是大部分框架都会默认支持的，额外这里要说明一下，RPCX支持QUIC而gRPC支持HTTP2.0。

QUIC（Quick UDP Internet Connection）是谷歌制定的一种互联网传输层协议，它基于UDP传输层协议，同时兼具TCP、TLS、HTTP/2等协议的可靠性与安全性，可以有效减少连接与传输延迟，更好地应对当前传输层与应用层的挑战。QUIC在应用程序层面就能实现不同的拥塞控制算法，不需要操作系统和内核支持，这相比于传统的TCP协议，拥有了更好的改造灵活性，非常适合在TCP协议优化遇到瓶颈的业务。

**RPC调用方式**

网络传输只是数据传输非常基础的一方面，从业务上来看，我们发起RPC调用，那么还需要RPC的调用方式

- 同步RPC：最常用的服务调用方式，开发比较简单，比较符合编程人员的习惯，代码相对容易维护些。
- 异步RPC：客户端发起服务调用之后，不同步等待响应，而是注册监听器或者回调函数，待接收到响应之后发起异步回调，驱动业务流程继续执行，实现起来相对复杂，但是高并发场景下性能会更好。
- 并行RPC：并行服务调用，一次I/O操作，可以发起批量调用，然后同步等待响应；


**服务治理**

RPC协议只规定了Client与Server之间的点对点调用流程，包括Stub、通信协议、RPC消息解析等部分。但是在实际应用中，远程过程调用的时候还需要考虑服务的路由、负载均衡、高可用问题，而去保障服务之间的调用就需要进行服务治理，服务治理基本就涵盖：服务注册和发现、限流、降级、熔断、重试、失败处理、负载均衡等。

