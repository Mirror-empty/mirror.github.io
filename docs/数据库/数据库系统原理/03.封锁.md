# 03.封锁

### 封锁类型


**1.读写锁**

- 互斥锁（Exclusive），简写为X锁，又称写锁。
- 共享锁（Shared），简写S锁，又称读锁。

有以下两个规定：

- 一个事务对数据对象A加了X锁，加可以对A进行读取和更新。加锁期间其他事务不能对A加任何锁。
- 一个事务对数据对象A加了S锁，可以对A进行读取操作，但是不能进行更新操作。加锁期间其它事务能对A加S锁，但是不能加X锁。

锁的兼容关系如下：

![zvQ1tU.png](https://s1.ax1x.com/2022/12/24/zvQ1tU.png)


**2.意向锁**

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的青年高考下，事务T想要对表A加X锁，就需要先检测是否有其他事务对表A或者表A中的任意一行加了锁，你们就需要对表A的每一行都检测一次，这是非常耗时的。

意向锁在原来读写锁的基础上引入了IX/IS,IX/IS都是表锁，用来表示某个事务想要在表中的某个数据行上加X锁或S锁。有以下两个规定：

- 一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或者更强的锁；
- 一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁。

通过引入意向锁，事务T想要对表A加X锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

相当于加了一层表判断。

各种锁的兼容关系如下：

![zvQcjA.png](https://s1.ax1x.com/2022/12/24/zvQcjA.png)

解释如下：

- 任意IS/IX锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
- 这里兼容关系针对的是表级锁，而表级的IX锁和行级的X锁兼容，两个事务可以对两个数据行加X锁。

（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）


### 封锁协议

**1.三级封锁协议**

**一级封锁协议**

事务T要修改数据A时必须加X锁，知道T结束才释放锁。

可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。

![zv7Kr8.png](https://s1.ax1x.com/2022/12/25/zv7Kr8.png)


多个事务不能解决

**二级封锁协议**

在一级的基础上，要求读取数据A时必须加S锁，读取完马上释放S锁。

可以解决读脏数据问题，因为如果一个事务在对数据A进行修改，根据1级封锁协议，会加X锁，那么就不能再加S锁，也就是不会读入数据。


